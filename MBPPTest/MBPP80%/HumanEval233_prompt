def generate_matrix(n):
        if n<=0:
            return [] 
        matrix=[row[:] for row in [[0]*n]*n]        
        row_st=0
        row_ed=n-1        
        col_st=0
        col_ed=n-1
        current=1        
        while (True):
            if current>n*n:
                break
            for c in range (col_st, col_ed+1):
                matrix[row_st][c]=current
                current+=1
            row_st+=1
            for r in range (row_st, row_ed+1):
                matrix[r][col_ed]=current
                current+=1
            col_ed-=1
            for c in range (col_ed, col_st-1, -1):
                matrix[row_ed][c]=current
                current+=1
            row_ed-=1
            for r in range (row_ed, row_st-1, -1):
                matrix[r][col_st]=current
                current+=1
            col_st+=1
        return matrix
The following is chain of thought:
Here's the structured chain of thought for the `generate_matrix` function:

1. **Input Validation**: Check if n is non-positive, return empty list immediately
2. **Matrix Initialization**: Create an n×n matrix filled with zeros using list comprehension
3. **Boundary Setup**: Initialize variables to track current spiral boundaries (row_st, row_ed, col_st, col_ed)
4. **Current Value**: Initialize counter starting at 1 (first value to fill)
5. **Spiral Filling Loop**: While current value doesn't exceed n²:
   - Fill top row from left to right, increment row_st
   - Fill right column from top to bottom, decrement col_ed
   - Fill bottom row from right to left, decrement row_ed
   - Fill left column from bottom to top, increment col_st
6. **Termination**: Break loop when all positions a