import sys 

def find_closet(A, B, C, p, q, r): 
	diff = sys.maxsize 
	res_i = 0
	res_j = 0
	res_k = 0
	i = 0
	j = 0
	k = 0
	while(i < p and j < q and k < r): 
		minimum = min(A[i], min(B[j], C[k])) 
		maximum = max(A[i], max(B[j], C[k])); 
		if maximum-minimum < diff: 
			res_i = i 
			res_j = j 
			res_k = k 
			diff = maximum - minimum; 
		if diff == 0: 
			break
		if A[i] == minimum: 
			i = i+1
		elif B[j] == minimum: 
			j = j+1
		else: 
			k = k+1
	return A[res_i],B[res_j],C[res_k]
The following is chain of thought:
1. **Initialization**: 
   - Initialize `diff` to the maximum possible integer value to track the smallest range found.
   - Initialize `res_i`, `res_j`, `res_k` to store indices of the current closest triplet.
   - Initialize pointers `i`, `j`, `k` to 0 for traversing arrays A, B, and C respectively.

2. **Loop through arrays**:
   - While all pointers are within their array bounds (`i < p`, `j < q`, `k < r`):
     - Compute the `minimum` and `maximum` of the current elements at indices `i`, `j`, `k`.
     - If the current range (`maximum - minimum`) is smaller than `diff`, update `diff` and store the current indices.
     - If `diff` becomes 0 (perfect match), break early.
     - Increment the pointer pointing to the smallest current element to try to reduce the range.

3. **Return result**:
   - After the loop, return the triplet `(A[res_i], B[r