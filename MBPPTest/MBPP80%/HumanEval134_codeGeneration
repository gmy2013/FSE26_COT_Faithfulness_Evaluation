CodeGeneration:
docstring says "toggles all bits except the most significant set bit and the least significant bit", which would indeed give 11 for n=13. However, the initial example calculation in the chain of thought incorrectly expected 9. Let me correct the understanding:

For n=13 (binary 1101):
- MSB (bit 3) and LSB (bit 0) remain unchanged
- Middle bits (bits 2 and 1) are toggled:
  - bit 2 was 1 → becomes 0
  - bit 1 was 0 → becomes 1
- Result: 1001 (binary) = 9

Wait, there's confusion in the chain of thought. Let me recalculate properly:

n = 13 (binary 1101)
MSB is position 3 (value 8), LSB is position 0 (value 1)
Bits to toggle: positions 2 and 1 (values 4 and 2)

Original: 8 + 4 + 0 + 1 = 13
After toggle: 8 + 0 + 2 + 1 = 11 (binary 1011)

So the correct result should be 11, not 9. The chain of thought had an error in the expected value.

The function works correctly:
- set_middle_bits(13) creates mask 6 (binary 0110)
- 13 XOR 6 = 11 (binary 1011)

Now let me implement the function based on the correct understanding:

```python
def toggle_middle_bits(n):
    """
    Toggles (flips) all bits of n except the most significant set bit and the least significant bit.
    
    Args:
        n (int): The input number
        
    Returns:
        int: The number with middle bits toggled
        
    Examples:
        >>> toggle_middle_bits(13)  # 1101 -> 1011 (11)
        11
        >>> toggle_middle_bits(10)  # 1010 -> 1100 (12)
        12
        >>> toggle_middle_bits(1)   # Edge case: 1 -> 1
        1
    """
    if n == 1:
        return 1
    return n ^ set_middle_bits(n)
```

The provided implementation is correct. The `set_middle_bits` function creates a mask that identifies all bits between the MSB and LSB (exclusive), and XORing with this mask toggles exactly those bits while preserving the MSB and LSB.
