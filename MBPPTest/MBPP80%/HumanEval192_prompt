def last(arr,x,n):
    low = 0
    high = n - 1
    res = -1  
    while (low <= high):
        mid = (low + high) // 2 
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            res = mid
            low = mid + 1
    return res
The following is chain of thought:
Here's the structured chain of thought for the given function:

1. **Function Purpose**: The function finds the last occurrence of element `x` in a sorted array `arr` of size `n` using binary search

2. **Initialization**:
   - Set `low` to 0 (start index)
   - Set `high` to `n-1` (end index)
   - Initialize `res` to -1 (default return value if element not found)

3. **Binary Search Loop**:
   - While `low` â‰¤ `high`, continue searching
   - Calculate `mid` as the average of `low` and `high`

4. **Comparison Logic**:
   - If `arr[mid] > x`: element is in left half, move `high` to `mid-1`
   - If `arr[mid] < x`: element is in right half, move `low` to `mid+1`
   - If `arr[mid] == x`: found occurrence, record position in `res` and continue searching right half for potential later occurrences

5. **Finding Last Occurrence**:
   - When element is found, instead of returning immediately, continue searching right half
   - This ensures we find the rightmost occurrence of `x`

6