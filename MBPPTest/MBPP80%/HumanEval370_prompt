def maximum_segments(n, a, b, c) : 
	dp = [-1] * (n + 10) 
	dp[0] = 0
	for i in range(0, n) : 
		if (dp[i] != -1) : 
			if(i + a <= n ): 
				dp[i + a] = max(dp[i] + 1, 
							dp[i + a]) 
			if(i + b <= n ): 
				dp[i + b] = max(dp[i] + 1, 
							dp[i + b]) 
			if(i + c <= n ): 
				dp[i + c] = max(dp[i] + 1, 
							dp[i + c]) 
	return dp[n]
The following is chain of thought:
1. **Initialize DP Array**: Create a DP array of size `n + 10` (to avoid index errors) with all values set to `-1` (indicating unreachable lengths). Set `dp[0] = 0` since zero length requires zero segments.
2. **Iterate Through Lengths**: For each length `i` from `0` to `n-1`:
   - If `dp[i]` is reachable (not `-1`):
     - For each segment length (`a`, `b`, `c`), if adding it to `i` doesn't exceed `n`, update `dp[i + segment]` to the maximum of its current value and `dp[i] +