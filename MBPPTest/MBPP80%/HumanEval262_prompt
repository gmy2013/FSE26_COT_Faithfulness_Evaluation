def find_longest_conseq_subseq(arr, n): 
	ans = 0
	count = 0
	arr.sort() 
	v = [] 
	v.append(arr[0]) 
	for i in range(1, n): 
		if (arr[i] != arr[i - 1]): 
			v.append(arr[i]) 
	for i in range(len(v)): 
		if (i > 0 and v[i] == v[i - 1] + 1): 
			count += 1
		else: 
			count = 1
		ans = max(ans, count) 
	return ans 
The following is chain of thought:
1. Sort the input array to group consecutive numbers.
2. Remove duplicates by creating a new list with only unique elements.
3. Initialize count to track current consecutive sequence length and ans to track maximum.
4. Iterate through the unique elements:
   - If current element is exactly one more than previous, increment count
   - Otherwise, reset count to 1 (start of new sequence)
   - Update maximum sequence length after each check
5. Return the maximum consecutive sequence length found.

The function handles:
- Empty arrays (n=0) by returning 0
- Single elements by ret