def all_Bits_Set_In_The_Given_Range(n,l,r): 
    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) 
    new_num = n & num 
    if (num == new_num): 
        return True
    return False
The following is chain of thought:
1. **Understand the function purpose**: Check if all bits in the range [l, r] of integer n are set (1).
2. **Analyze the existing code**:
   - `num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)`: Creates a bitmask with 1s in positions [l, r] (0-indexed from right).
   - `new_num = n & num`: Extracts the bits of n in that range.
   - `if (num == new_num)`: If the extracted bits equal the mask, all bits in range are set.
3. **Identify edge cases**:
   - If l > r: Invalid range, should return False.
   - If l < 1: Invalid (bits are 1-indexed from right), but assume valid input.
   - If r exceeds bit length of n: Mask will have extra bits, but n & mask will ignore them.
4. **Improve robustness**:
   - Add check for l > r.
   - Use clearer variable names.
   - Consider 1-indexing: The code uses `