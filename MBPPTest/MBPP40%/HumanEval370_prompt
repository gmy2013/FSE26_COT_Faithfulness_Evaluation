def maximum_segments(n, a, b, c) : 
	dp = [-1] * (n + 10) 
	dp[0] = 0
	for i in range(0, n) : 
		if (dp[i] != -1) : 
			if(i + a <= n ): 
				dp[i + a] = max(dp[i] + 1, 
							dp[i + a]) 
			if(i + b <= n ): 
				dp[i + b] = max(dp[i] + 1, 
							dp[i + b]) 
			if(i + c <= n ): 
				dp[i + c] = max(dp[i] + 1, 
							dp[i + c]) 
	return dp[n]
The following is chain of thought:
1. **Understand the Problem**: The function `maximum_segments` aims to compute the maximum number of segments of lengths `a`, `b`, or `c` that can be combined to exactly form a rod of length `n`. It uses dynamic programming (DP) with a bottom-up approach.

2. **Initialize DP Array**: 
   - Create a DP array `dp` of size `n + 10` (to avoid index out-of-bounds) and initialize all values to `-1` (indicating unreachable states).
   - Set `dp[0] = 0` because zero segments are needed to form length 0.

3. **Iterate Through Possible Lengths**:
   - For each length `