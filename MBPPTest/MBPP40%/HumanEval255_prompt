def find_Min_Swaps(arr,n) : 
    noOfZeroes = [0] * n 
    count = 0 
    noOfZeroes[n - 1] = 1 - arr[n - 1] 
    for i in range(n-2,-1,-1) : 
        noOfZeroes[i] = noOfZeroes[i + 1] 
        if (arr[i] == 0) : 
            noOfZeroes[i] = noOfZeroes[i] + 1
    for i in range(0,n) : 
        if (arr[i] == 1) : 
            count = count + noOfZeroes[i] 
    return count 
The following is chain of thought:
The function `find_Min_Swaps` calculates the minimum number of adjacent swaps required to group all 1's together in a binary array.

**Chain of Thought:**
1. **Problem Analysis:** The goal is to group all 1's together with minimum adjacent swaps. This is equivalent to counting the total "effort" (number of zeros each 1 must swap past) to bring all 1's together.
2. **Key Insight:** For each 1, the number of swaps needed is the number of zeros to its right (since swapping a 1 rightward past zeros groups