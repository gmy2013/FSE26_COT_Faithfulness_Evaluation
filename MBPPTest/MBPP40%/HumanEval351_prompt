def nCr_mod_p(n, r, p): 
	if (r > n- r): 
		r = n - r 
	C = [0 for i in range(r + 1)] 
	C[0] = 1 
	for i in range(1, n + 1): 
		for j in range(min(i, r), 0, -1): 
			C[j] = (C[j] + C[j-1]) % p 
	return C[r] 
The following is chain of thought:
Here's the structured chain of thought for the nCr_mod_p function:

1. **Handle Symmetry Property**: Check if r is greater than n-r, and if so, set r = n - r. This optimization reduces computation time by working with the smaller value.

2. **Initialize DP Array**: Create a DP array C of size r+1 initialized with zeros. This array will store intermediate combinations modulo p.

3. **Base Case**: Set C[0] = 1, representing the base case where choosing 0 items from any set always gives 1 