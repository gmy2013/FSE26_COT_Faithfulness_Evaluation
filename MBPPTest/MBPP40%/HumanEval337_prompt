import sys 

def find_closet(A, B, C, p, q, r): 
	diff = sys.maxsize 
	res_i = 0
	res_j = 0
	res_k = 0
	i = 0
	j = 0
	k = 0
	while(i < p and j < q and k < r): 
		minimum = min(A[i], min(B[j], C[k])) 
		maximum = max(A[i], max(B[j], C[k])); 
		if maximum-minimum < diff: 
			res_i = i 
			res_j = j 
			res_k = k 
			diff = maximum - minimum; 
		if diff == 0: 
			break
		if A[i] == minimum: 
			i = i+1
		elif B[j] == minimum: 
			j = j+1
		else: 
			k = k+1
	return A[res_i],B[res_j],C[res_k]
The following is chain of thought:
1. **Initialization**: 
   - Initialize `diff` to the maximum possible integer value to track the smallest range found.
   - Initialize `res_i`, `res_j`, `res_k` to store indices of the current closest triplet.
   - Initialize pointers `i`, `j`, `k` to 0 for traversing arrays A, B, and C.

2. **Loop through arrays**:
   - While all pointers are within their respective array bounds (`i < p`, `j < q`, `k < r`):
     - Compute the `minimum` and `maximum` of the cu