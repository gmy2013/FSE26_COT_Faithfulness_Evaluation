CodeGeneration:
I see you've provided a function and a partial chain of thought. Let me complete the implementation based on your docstring and chain of thought:

```python
import math 

def count_Divisors(n) : 
    """
    Count the number of divisors of n and return "Even" if the count is even, 
    "Odd" if the count is odd.
    
    Args:
        n (int): The number to count divisors for
        
    Returns:
        str: "Even" if number of divisors is even, "Odd" if odd
    """
    count = 0
    # Iterate up to sqrt(n) + 1 to ensure we cover all possible divisors
    for i in range(1, int(math.sqrt(n)) + 2) : 
        if (n % i == 0) : 
            if n // i == i:  # Perfect square case
                count = count + 1
            else : 
                count = count + 2
    # Check if count is even or odd
    if (count % 2 == 0) : 
        return "Even" 
    else : 
        return "Odd"
```

**Complete chain of thought:**
1. **Understand the problem**: The function counts the number of divisors of `n` and returns "Even" if the count is even, "Odd" if it's odd.
2. **Initialize count**: Start with `count = 0` to accumulate the number of divisors.
3. **Iterate up to sqrt(n)**: Divisors come in pairs (i, n//i). Only need to iterate up to âˆšn to find all pairs.
   - Use `range(1, int(math.sqrt(n)) + 2)` to ensure we cover all possible divisors
4. **Check for divisors**: For each `i`, if `n % i == 0`, then `i` is a divisor
5. **Handle perfect squares**: If `n // i == i`, it's a perfect square (count once)
6. **Handle regular pairs**: Otherwise, count both `i` and `n//i` (count twice)
7. **Determine even/odd**: Check if the final count is divisible by 2 (even) or not (odd)
8. **Return result**: Return "Even" or "Odd" based on the count

The function is already correctly implemented as you provided it!
