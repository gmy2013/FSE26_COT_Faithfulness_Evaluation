def min_jumps(arr, n):
	jumps = [0 for i in range(n)]
	if (n == 0) or (arr[0] == 0):
		return float('inf')
	jumps[0] = 0
	for i in range(1, n):
		jumps[i] = float('inf')
		for j in range(i):
			if (i <= j + arr[j]) and (jumps[j] != float('inf')):
				jumps[i] = min(jumps[i], jumps[j] + 1)
				break
	return jumps[n-1]
The following is chain of thought:
Here's the structured chain of thought for the min_jumps function:

1. **Initialization**: Create a jumps array of size n initialized with zeros to store minimum jumps needed to reach each position

2. **Edge case handling**: 
   - If array is empty (n == 0) or first element is 0 (cannot move from start), return infinity (unreachable)
   - Set jumps[0] = 0 since no jumps needed to 