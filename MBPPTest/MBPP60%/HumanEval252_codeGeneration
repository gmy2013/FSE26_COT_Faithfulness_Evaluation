CodeGeneration:
result `res`.
5. After the loop, if `n` is still greater than 1, it means `n` is a prime number itself (since we've divided out all factors up to sqrt(n)), so multiply `res` by (1 + n) to account for the factors 1 and n.
6. Return `res`.

However, note that the code does not step by 2 in the for-loop. Since `n` is now odd, only odd numbers will divide it, but the loop still checks every integer from 3 to sqrt(n). This is inefficient because it checks even numbers unnecessarily. We can optimize by stepping by 2.

Let me correct the code to step by 2 in the for-loop for efficiency.

Here is the corrected code:

```python
import math

def sum_of_odd_Factors(n): 
    res = 1
    while n % 2 == 0: 
        n = n // 2 
    for i in range(3, int(math.sqrt(n)) + 1, 2): 
        count = 0
        curr_sum = 1
        curr_term = 1
        while n % i == 0: 
            count += 1 
            n = n // i 
            curr_term *= i 
            curr_sum += curr_term    
        res *= curr_sum  
    if n >= 2: 
        res *= (1 + n) 
    return res
```

This code now efficiently iterates only over odd potential factors.
