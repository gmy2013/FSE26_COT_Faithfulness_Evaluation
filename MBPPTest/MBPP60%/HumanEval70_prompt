import math 
def get_Pos_Of_Right_most_Set_Bit(n): 
    return int(math.log2(n&-n)+1)   
def set_Right_most_Unset_Bit(n): 
    if (n == 0): 
        return 1
    if ((n & (n + 1)) == 0):     
        return n 
    pos = get_Pos_Of_Right_most_Set_Bit(~n)      
    return ((1 << (pos - 1)) | n) 
The following is chain of thought:
1. The function `set_Right_most_Unset_Bit` takes an integer `n`.
2. If `n` is 0, return 1 because the rightmost unset bit in 0 is at position 1 (binary representation '0' has no set bits, so the first unset bit is at the least significant position).
3. Check if `n` has all bits set (i.e., `n` is of the form 2^k - 1). This is done by verifying if `n & (n + 1)` equals 0. If true, return `n` because there are no unset bits to set.
4. If there are unset bits, compute the bitwise NOT of `n` to flip all bits. This transforms unset bits in `n` to set bits in `~n`.
5. Use `get_Pos_Of_Right_most_Set_Bit` on `~n` to find the position of the rightmost set bit in `