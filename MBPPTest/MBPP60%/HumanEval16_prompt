def min_Jumps(a, b, d): 
    temp = a 
    a = min(a, b) 
    b = max(temp, b) 
    if (d >= b): 
        return (d + b - 1) / b 
    if (d == 0): 
        return 0
    if (d == a): 
        return 1
    else:
        return 2
The following is chain of thought:
Here is the structured chain of thought for analyzing the min_Jumps function:

1. **Function Purpose Analysis**: The function appears to calculate the minimum number of jumps needed to cover a distance 'd' using two jump lengths 'a' and 'b', where we can use either jump type in any order.

2. **Initial Variable Handling**:
   - Store original 'a' value in 'temp'
   - Reassign 'a' to be the smaller of (a, b)
   - Reassign 'b' to be the larger of (original a, b) using 'temp'
   - This ensures a ≤ b for the remaining logic

3. **Special Case Handling**:
   - If d ≥ b: Use formula (d + b - 1) / b which calculates ceiling(d/b) using integer arithmetic
   - If d == 0: No jumps needed, return 0
   - If d == a: Exactly one jump of length 'a' suffices, return 1

4. **Default Case**:
   - For all other cases (where 0 < d < b and d ≠ a), return 2
   - This handles cases where we need a combination of jumps (e.g., a+b, or a+a when a < d < b)

5. **Edge Case Consideration**:
   - The function assumes we can always reach distance d with at most 2 jumps when 0 < d < b
   - This works because with two jumps we can cover any distance up to a