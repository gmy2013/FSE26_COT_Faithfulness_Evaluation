def nCr_mod_p(n, r, p): 
	if (r > n- r): 
		r = n - r 
	C = [0 for i in range(r + 1)] 
	C[0] = 1 
	for i in range(1, n + 1): 
		for j in range(min(i, r), 0, -1): 
			C[j] = (C[j] + C[j-1]) % p 
	return C[r] 
The following is chain of thought:
Here's the structured chain of thought for the nCr_mod_p function:

1. **Handle Symmetry Property**: If r > n-r, set r = n-r to minimize computations using the binomial coefficient symmetry property (nCr = nC(n-r))

2. **Initialize DP Array**: Create a DP array C of size r+1 initialized to 0 to store intermediate combinations

3. **Base Case**: Set C[0] = 1 since nC0 = 1 for any n

4. **Iterative Computation**: Use dynamic programming with Pascal's triangle approach:
   - Outer loop: iterate from 1 to n (all possible n values)
   - Inner loop: iterate backwards from min(i, r) down