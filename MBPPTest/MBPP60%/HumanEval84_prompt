def sum_Of_Primes(n): 
    prime = [True] * (n + 1)  
    p = 2
    while p * p <= n: 
        if prime[p] == True:  
            i = p * 2
            while i <= n: 
                prime[i] = False
                i += p 
        p += 1    
    sum = 0
    for i in range (2,n + 1): 
        if(prime[i]): 
            sum += i 
    return sum
The following is chain of thought:
1. The function `sum_Of_Primes(n)` calculates the sum of all prime numbers up to and including `n`.
2. It uses the Sieve of Eratosthenes algorithm to mark non-prime numbers in a boolean list `prime` of length `n+1`.
3. Initialize `prime` with all elements set to `True`, assuming initially all numbers are prime.
4. Start with `p = 2`, the smallest prime number.
5. While `p * p <= n`, check if `p` is still marked as prime (not marked 