def find_First_Missing(array,start,end): 
    if (start > end): 
        return end + 1
    if (start != array[start]): 
        return start; 
    mid = int((start + end) / 2) 
    if (array[mid] == mid): 
        return find_First_Missing(array,mid+1,end) 
    return find_First_Missing(array,start,mid) 
The following is chain of thought:
Here's the structured chain of thought for the find_First_Missing function:

1. **Base Case 1 - Invalid Range**: If start index exceeds end index, return end + 1
   - This handles the case where the entire array is properly sequenced
   - The next missing number would be one beyond the last element

2. **Base Case 2 - Immediate Detection**: If the first element doesn't match its index, return start
   - This quickly identifies when the missing number is at the very beginning

3. **Binary Search Setup**: Calculate mid-point using integer division
   - Splits the search space in half for efficient O(log n) time complexity

4. **Recursive Case 1 - Right Half Search**: If array[mid] equals mid, sear