def all_Bits_Set_In_The_Given_Range(n,l,r): 
    num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1) 
    new_num = n & num 
    if (num == new_num): 
        return True
    return False
The following is chain of thought:
1. **Understand the function purpose**: Check if all bits in the range [l, r] of integer `n` are set (1).
2. **Analyze the existing code**:
   - `num = ((1 << r) - 1) ^ ((1 << (l - 1)) - 1)`: Creates a bitmask with 1s in positions [l, r] (0-indexed from right).
   - `new_num = n & num`: Extracts the bits of `n` in the range [l, r].
   - `if (num == new_num)`: Checks if the extracted bits exactly match the mask (all 1s).
3. **Identify potential issue**: The mask calculation assumes 1-indexed bit positions (common in problem contexts), but Python uses 0-indexing. However, the mask logic is correct for inclusive range [l, r] with l and r starting at 1 for the le