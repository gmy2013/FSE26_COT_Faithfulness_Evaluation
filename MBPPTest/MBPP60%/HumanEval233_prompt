def generate_matrix(n):
        if n<=0:
            return [] 
        matrix=[row[:] for row in [[0]*n]*n]        
        row_st=0
        row_ed=n-1        
        col_st=0
        col_ed=n-1
        current=1        
        while (True):
            if current>n*n:
                break
            for c in range (col_st, col_ed+1):
                matrix[row_st][c]=current
                current+=1
            row_st+=1
            for r in range (row_st, row_ed+1):
                matrix[r][col_ed]=current
                current+=1
            col_ed-=1
            for c in range (col_ed, col_st-1, -1):
                matrix[row_ed][c]=current
                current+=1
            row_ed-=1
            for r in range (row_ed, row_st-1, -1):
                matrix[r][col_st]=current
                current+=1
            col_st+=1
        return matrix
The following is chain of thought:
Here's the structured chain of thought for the generate_matrix function:

1. **Input Validation**: First check if n is less than or equal to 0, return empty list if true
2. **Matrix Initialization**: Create an n x n matrix filled with zeros using list comprehension
3. **Boundary Setup**: Initialize variables to track the current spiral boundaries (row_st, row_ed, col_st, col_ed)
4. **Current Value**: Initialize current counter starting at 1
5. **Spiral Filling Loop**: While current value doesn't exceed nÂ²:
   - Fill top row from left to right, then move top boundary down
   - Fill right column from top to bottom, then move right bou