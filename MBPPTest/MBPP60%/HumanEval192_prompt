def last(arr,x,n):
    low = 0
    high = n - 1
    res = -1  
    while (low <= high):
        mid = (low + high) // 2 
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            res = mid
            low = mid + 1
    return res
The following is chain of thought:
Here's the structured chain of thought for the given function:

1. **Function Purpose**: The function implements a binary search variant to find the last occurrence of element `x` in a sorted array `arr` of size `n`.

2. **Initialization**: 
   - `low = 0` (start index of search range)
   - `high = n - 1` (end index of search range)
   - `res = -1` (stores the result, initialized to -1 indicating not found)

3. **Binary Search Loop**: While `low <= high` (search range is valid):
   - Calculate `mid = (low + high) // 2` (middle index)
   - If `arr[mid] > x`: element is in left half, set `high = mid - 1`
   - If `arr[mid] < x`: element is in right half, set `low = mid + 1`
   - If `arr[mid] == x`: found occurrence, store position in `res` and continue searching right half with `low = mid + 1` to