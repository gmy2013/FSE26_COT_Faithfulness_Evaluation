def min_jumps(arr, n):
	jumps = [0 for i in range(n)]
	if (n == 0) or (arr[0] == 0):
		return float('inf')
	jumps[0] = 0
	for i in range(1, n):
		jumps[i] = float('inf')
		for j in range(i):
			if (i <= j + arr[j]) and (jumps[j] != float('inf')):
				jumps[i] = min(jumps[i], jumps[j] + 1)
				break
	return jumps[n-1]
The following is chain of thought:
Here's the structured chain of thought for the given function:

1. **Initialization**: Create a jumps array of size n initialized with 0 to store minimum jumps needed to reach each position
2. **Edge Case Handling**: Check if array is empty (n=0) or starting position has 0 reach (arr[0]==0), return infinity since no path exists
3. **Base Case**: Starting position requires 0 jumps to reach itself (jumps[0] = 0)
4. **Main Loop**: For each position i from 1 to n-1:
   - Initialize jumps[i] to infinity (unreachable by default)
   - Check all previous po