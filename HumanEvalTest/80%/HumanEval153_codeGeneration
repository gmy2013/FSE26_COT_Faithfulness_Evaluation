CodeGeneration:
elif char.islower():
                sm += 1
        
        strength = cap - sm
        
        if strength > max_strength:
            max_strength = strength
            strongest_extension = extension
    
    return f"{class_name}.{strongest_extension}"
```

Here's the complete implementation:

```python
def Strongest_Extension(class_name, extensions):
    strongest_extension = None
    max_strength = float('-inf')
    
    for extension in extensions:
        cap = 0
        sm = 0
        for char in extension:
            if char.isupper():
                cap += 1
            elif char.islower():
                sm += 1
        
        strength = cap - sm
        
        if strength > max_strength:
            max_strength = strength
            strongest_extension = extension
    
    return f"{class_name}.{strongest_extension}"
```

This implementation:
1. Initializes variables to track the strongest extension and its strength
2. Iterates through each extension
3. Counts uppercase and lowercase letters in each extension
4. Calculates the strength as CAP - SM
5. Updates the strongest extension when a higher strength is found
6. Returns the result in the required format

The solution handles the case where multiple extensions have the same strength by keeping the first one encountered with the maximum strength value, since we only update when we find a strictly greater strength.
