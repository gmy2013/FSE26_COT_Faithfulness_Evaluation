CodeGeneration:
e, we can compare each symmetric pair and count how many pairs are not equal. The number of changes required is exactly the number of such mismatched pairs, because for each mismatched pair, we can change one element to match the other (which counts as one change per pair).

However, note that if the array has an odd length, the middle element does not need to be paired and can be left as is.

So, the algorithm is:
1. Initialize a counter for changes to 0.
2. Use two pointers: one starting at the beginning (i) and one at the end (j) of the array.
3. While i < j:
   - If arr[i] != arr[j], increment the change counter.
   - Move i forward and j backward.
4. Return the counter.

Let's test with the examples:
- [1,2,3,5,4,7,9,6]: 
  Compare (1,6) -> not equal -> change count=1
  Compare (2,9) -> not equal -> change count=2
  Compare (3,7) -> not equal -> change count=3
  Compare (5,4) -> not equal -> change count=4 -> returns 4 (matches example)
- [1,2,3,4,3,2,2]:
  Compare (1,2) -> not equal -> change count=1
  Compare (2,2) -> equal
  Compare (3,3) -> equal
  The middle element (4) is ignored -> returns 1 (matches example)
- [1,2,3,2,1]:
  All pairs are equal -> returns 0 (matches example)

Therefore, the implementation is straightforward.

Here is the code:
```python
def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """
    n = len(arr)
    changes = 0
    left = 0
    right = n - 1
    while left < right:
        if arr[left] != arr[right]:
            changes += 1
        left += 1
        right -= 1
    return changes
```
