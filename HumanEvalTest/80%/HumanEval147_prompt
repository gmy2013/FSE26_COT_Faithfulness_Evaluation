
def get_max_triples(n):
    """
    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.

    Example :
        Input: n = 5
        Output: 1
        Explanation: 
        a = [1, 3, 7, 13, 21]
        The only valid triple is (1, 7, 13).
    """

The following is chain of thought:
We are counting triples (i < j < k) such that (a[i] + a[j] + a[k]) % 3 == 0.
First, note that a[i] = i*i - i + 1.
We can simplify modulo 3 to avoid large numbers.

Compute a[i] mod 3:
Let i mod 3 be r (r in {0,1,2}).
Then:
i = 3q + r.
i*i = (3q+r)^2 = 9q^2 + 6qr + r^2.
So i*i - i + 1 = (9q^2+6qr+r^2) - (3q+r) + 1 = 9q^2+6qr -3q + r^2 - r + 1.
Now modulo 3:
9q^2 %3=0, 6qr%3=0, -3q%3=0.
So a[i] %3 = (r^2 - r + 1) % 3.

Now compute for each r in {0,1,2}:
If r=0: (0 - 0 + 1) %3 = 1.
If r=1: (1 - 1 + 1) %3 = 1.
If r=2: (4 - 2 + 1) %3 = (3) %3 = 0.

So:
- If i %3 == 0 or i%3==1, then a[i] %3 = 1.
- If i %3 == 2, then a[i] %3 = 0.

Therefore, the value of a[i] mod 3 depends only on i mod 3:
Let:
count0 = number of i in [1, n] such that i %3 == 2 (since these give a[i] %3=0)
count1 = number of i in [1, n] such that i %3 ==0 or i%3==1 (these give a[i] %3=1)

Now we need triples (i,j,k) with i<j<k such that (a[i]+a[j]+a[k]) %3==0.
Since each a[i] is either 0 or 1 mod3, the sum mod3 can be:
0+0+0=0, 0+1+2=0 (but we don't have 2), so only possibilities are:
0+0+0=0, and 1+1+1=3=0.

So we need either:
- Three indices with a[i]=0 mod3 (i.e., i%3==2), OR
- Three indices with a[i]=1 mod3 (i.e., i%3==0 or 1).

Therefore, the total number of triples is:
C(count0, 3) + C(count1, 3)

Now we compute count0 and count1 for i from 1 to n.

For i in [1, n]:
i %3 can be 0,1,2.
Let n be given.

The number of integers in [1, n] with remainder r modulo 3 is:
count_r = (n - r + 2) // 3   [for r=0,1,2] but careful: for r=0, we need to adjust.

Alternatively:
count0 = number of multiples of 3 in [1,n] = n//3
count1 = number of integers with remainder 1 = (n+2)//3? Actually:

For i=1 to n:
Let k = n // 3, then:
remainder 1: count = k + (1 if n%3>=1 else 0)
remainder 2: count = k + (1 if n%3>=2 else 0)
remainder 0: count = k

But here:
We need:
count0 = number of i with i%3==2 (which gives a[i]=0 mod3)
count1 = number of i with i%3==0 or 1 (which gives a[i]=1 mod3) = n - count0

So:
count0 = (n - 2 + 3) // 3? Actually:
The number of integers i in [1,n] with i%3==2 is:
Let k = (n - 2) // 3 + 1   if n>=2, but we can use:
count0 = (n + 1) // 3   if we consider starting at 1? Actually:

For n=5: i=1,2,3,4,5 -> remainders: 1,2,0,1,2 -> so count0 (remainder2) = 2.
(n+1)//3 = (5+1)//3=6//3=2 -> correct.

For n=4: i=1,2,3,4 -> remainders:1,2,0,1 -> count0=1.
(4+1)//3=5//3=1 -> correct.

For n=3: i=1,2,3 -> remainders:1,2,0 -> count0=1.
(3+1)//3=4//3=1 -> correct.

For n=2: i=1,2 -> remainders:1,2 -> count0=1.
(2+1)//3=3//3=1 -> correct.

For n=1: i=1 -> remainder1 -> count0=0.
(1+1)//3=2//3=0 -> correct.

So count0 = (n+1) // 3
Then count1 = n - count0 = n - (n+1)//3

Now, total triples = C(count0, 3) + C(count1, 3)

We need to compute combinations: C(x,3) = x*(x-1)*(x-2)//6 if x>=3, else 0.

So code:
count0 = (n+1) // 3
count1 = n - count0

triples = (count0*(count0-1)*(count0-2))//6 + (count1*(count1-1)*(count1-2))//6

Return triples.

Let's test with n=5:
count0 = (5+1)//3 = 6//3=2
count1 = 5