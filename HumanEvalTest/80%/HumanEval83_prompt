
def starts_one_ends(n):
    """
    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    """

The following is chain of thought:
To solve this problem, we need to count the n-digit positive integers that either start with 1 or end with 1 (or both). We can break this down using the principle of inclusion-exclusion to avoid double-counting numbers that both start and end with 1.

1. **Total n-digit numbers**: The range is from 10^(n-1) to 10^n - 1. There are 9 * 10^(n-1) n-digit numbers (since the first digit can be 1-9 and the rest 0-9).

2. **Numbers starting with 1**: The first digit is fixed as 1. The remaining n-1 digits can be any digit from 0 to 9. So, there are 10^(n-1) such numbers.

3. **Numbers ending with 1**: The last digit is fixed as 1. The first digit can be from 1 to 9 (to be n-digit) and the middle n-2 digits can be 0-9. So, there are 9 * 10^(n-2) such numbers? Wait: actually, for the first digit (which cannot be 0) there are 9 choices (1-9), and for the last digit it is fixed as 1. The middle n-2 digits have 10 choices each. So total is 9 * 10^(n-2). However, note that if n=1, then there is no middle digit. So we need to handle n=1 separately.

But wait: for n=1, numbers ending with 1 are just the number 1. And there is only one 1-digit number that ends with 1. Also, for n=1, numbers starting with 1 are the same (only number 1). So for n=1, the count should be 1.

Now, if we use the formula for numbers ending with 1: for n>=2, it is 9 * 10^(n-2). For n=1, it should be 1. Alternatively, we can think: for numbers ending with 1, the first digit has 9 choices (1-9) and the last digit is fixed. But for n=1, the first and last are the same. So if n=1, the count is 1 (only digit 1). So we can write a general expression: numbers ending with 1 = 9 * 10^(n-2) for n>=2, and 1 for n=1.

4. **Numbers that both start and end with 1**: The first and last digits are fixed as 1. The middle n-2 digits can be 0-9. So there are 10^(n-2) such numbers. For n=1, it is 1 (the number 1).

5. Now, by inclusion-exclusion: 
   Count = (numbers starting with 1) + (numbers ending with 1) - (numbers both starting and ending with 1)

So for n>=2:
   Count = 10^(n-1) + 9 * 10^(n-2) - 10^(n-2) = 10^(n-1) + 8 * 10^(n-2)

Simplify: 10^(n-1) = 10 * 10^(n-2). So:
   Count = 10 * 10^(n-2) + 8 * 10^(n-2) = 18 * 10^(n-2)

For n=1:
   Numbers starting with 1: 1
   Numbers ending with 1: 1
   Numbers both: 1
   So count = 1 + 1 - 1 = 1.

And note that 18 * 10^(n-2) for n=1 would be 18 * 10^(-1) which is not defined. So we need to handle n=1 separately.

Alternatively, we can write a unified expression:

Observe that for n=1, the count is 1.
For n>=2, count = 18 * 10^(n-2)

But we can also express without case distinction by using:
   Count = 10^(n-1) + 9 * 10^(n-2) - 10^(n-2)   for n>=2, and for n=1 we can check.

Alternatively, we can use:

Let A = set of numbers starting with 1, |A| = 10^(n-1)
Let B = set of numbers ending with 1, |B| = 9 * 10^(n-2) for n>=2, and 1 for n=1.
But to avoid if, we can note that for n=1, |B| = 1 = 9 * 10^(-1) which is not integer. So better to use if.

However, we can compute without if by:

|A| = 10^(n-1)
|B| = 9 * 10^(n-2)   if n>=2, but for n=1 we need to define as 1.

So in code, we can do:

if n == 1:
    return 1
else:
    return 10**(n-1) + 9 * 10**(n-2) - 10**(n-2)

Which simplifies to:
if n==1: return 1
else: return 10**(n-1) + 8 * 10**(n-2)

And since 10**(n-1) = 10 * 10**(n-2), so it is 18 * 10**(n-2) for n>=2.

So code:

if n == 1:
    count = 1
else:
    count = 18 * (10 ** (n