

def modp(n: int, p: int):
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """

The following is chain of thought:
We are computing 2^n mod p.
 Since n can be large (like 1101), we use exponentiation by squaring to avoid large intermediate numbers.
 Steps:
 1. If n is 0, return 1 (since 2^0 = 1).
 2. Initialize result as 1.
 3. While n > 0:
      a. If n is odd, multiply result by 2 and take mod p.
      b. Now n is even: square 2 (i.e., compute 2^2 mod p) and set n = n // 2.
 4. Actually, we can think in terms of base = 2, and we are computing base^n mod p.
    We can use iterative exponentiation:
        result = 1
        base = 2
        while n:
            if n % 2 == 1:
                result = (result * base) % p
            base = (base * base) % p
            n //= 2
 5. Return result.

 Let's test with examples:
   n=3, p=5: 
        n=3 (odd): result = (1*2)%5=2, base becomes (2*2)%5