

def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """

The following is chain of thought:
To solve this problem, we need to find the largest divisor of a given number `n` that is smaller than `n`. The largest divisor (other than `n` itself) will be found by checking divisors from `n-1` down to 1, but we can optimize by starting from the square root of `n` and checking both factors. However, since we want the largest divisor (which is actually the complement of the smallest divisor), we can iterate backwards from `n-1` to 1 and return the first divisor we find. Alternatively, we can iterate from 2 to `n//2` (since the largest divisor cannot exceed `n//2` for `n>1`) and return the last divisor found. But for efficiency, we can start from `n//2` and go downwards to 1.

But note: the largest divisor of `n` (other than `n`) is actually `n // p`, where `p` is the smallest prime divisor of `n`. However, without finding primes, we can simply iterate from `n//2` down to 1 and return the first number that divides `n` evenly.

However, for even numbers, the largest divisor is `n/2`, and for odd numbers, it might be lower. So we can start at `n//2` and go downwards until we find a divisor.

But if `n` is 1, there is no divisor smaller than 1, so we should handle that.

Alternatively, we can iterate from `n-1` down to 1, but that is inefficient for large `n`.

Better approach: iterate from `int(n**0.5)` to 1 and check both factors? Actually, the largest divisor is `n // smallest_prime_factor`, but we don't have that.

Alternatively, we can iterate from `n//2` down to 1. For example, for n=15, n//2=7, then we check 7: 15%7=1, then 6:15%6=3, then 5:15%5=0 -> return 5.

So we can do:

for i in range(n//2, 0, -1):
    if n % i == 0:
        return i

This will work for all n>1. For n=1, we should return None or 0? But the problem says "smaller than n", so for n=1 there is none. However, the docstring doesn't specify edge cases. But the problem says "smaller than n", so for n=1, we should return nothing? But the function returns int, so we might return 0 or None? But the examples don't include n=1.

Actually, the problem states "smaller than n", so for n=1, there is no number smaller than 1 that divides it. So we should return None? But the return type is int. So we might return 0? But 0 is not a divisor. Alternatively, we can assume n>=2.

But to be safe, we handle n=1.

However, the docstring example is for n=15.

So code:

if n == 1:
    return 0   # or None? But return type is int, so we return 0 as placeholder? But it's not correct. Alternatively, we can return 0 for n=1.

But actually, the problem says "smaller than n", so for n=1, it should be undefined. But to avoid error, we return 0.

Alternatively, we can raise an exception for n<2.

But the problem doesn't specify, so we a