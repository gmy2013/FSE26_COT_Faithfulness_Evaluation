
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''

The following is chain of thought:
To solve this problem, we need to check two conditions:
1. The list must be sorted in non-decreasing order (each element should be <= the next).
2. There should be no more than one duplicate of any number (i.e., no number appears more than twice).

We can iterate through the list and check:
- If any element is greater than the next, the list is not sorted -> return False.
- Also, we need to check for duplicates: if a number appears more than twice, return False.

However, note the examples: [1,2,2,3,3,4] is allowed (each duplicate appears exactly twice) but [1,2,2,2,3,4] is not (2 appears three times).

We can use a dictionary to count occurrences. But note: we only care about numbers that appear more than twice. So we can count while iterating and if any count exceeds 2, return False.

Alternatively, we can combine both checks in one pass.

Plan:
1. If the list has 0 or 1 element, return True.
2. Initialize a dictionary for counts.
3. Iterate from index 0 to len(lst)-2:
   - Check if current element > next: if yes, return False.
   - Also, update the count for current element. But note: we need to check counts for all elements, including the last one.
4. After the loop, update count for the last element.
5. Check if any value in the count dictionary is greater than 2. If yes, return False.
6. Otherwise, return True.

However, we can update counts as we traverse and check for duplicates only when we see the same number again? Actually, we can check for count exceeding 2 immediately when updating.

But careful: when we update the count for an element, if it becomes 3, we can return False immediately.

So we can do:
- Initialize count_dict = {}
- For i in range(len(lst)-1):
   - if lst[i] > lst[i+1]: return False
   - count_dict[lst[i]] = count_dict.get(lst[i], 0) + 1
   - if count_dict[lst[i]] > 2: return False
- Then handle the last element: update its count and check if it exceeds 2.

But wait: what if the last element is duplicate and we haven't checked it? So we need to update the last element as well.

Alternatively, we can iterate over all elements to count duplicates first? But that would require two passes.

We can do one pass for both checks without pre-counting: actually, we can check the sorted condition and the duplicate condition simultaneously.

However, for duplicates: we need to know the entire list to