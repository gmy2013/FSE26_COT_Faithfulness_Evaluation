
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''

The following is chain of thought:
1. The function needs to check if integer `a` is a perfect cube (cube of some integer).
2. Since cubes can be negative (e.g., -1 is cube of -1), we need to handle negative inputs.
3. For a=0, it should return True (0 is cube of 0).
4. Approach: Check if there exists an integer `x` such that `x*x*x == a`.
5. We can compute the cube root of `a` and check if it's an integer. However, due to floating point precision, we should be cautious.
6. Better approach: Check if the rounded cube root raised to the power 3 equals `a`.
7. Since `a` might be negative, we should take the absolute value for cube root calculation, but preserve the sign.
8. Alternatively, we can iterate through possible integers, but this might be inefficient for large numbers.
9. Efficient method: Compute `x = round(a ** (1/3))` and check if `x*x*x == a`.
10. However, for negative `a`, we need to adjust: we can compute `x = round(abs(a) ** (1/3)) * (-1 if a < 0 else 1)`.
11. But note: in Python, negative numbers raised to fractional power might involve complex numbers, so we should avoid that.
12. Instead, we can compute the cube root using: `x = round(a ** (1/3))` if a>=0, but for negative a, we can do `-round((-a) ** (1/3))`.
13. However, we can use a unified approach: `x = round(a ** (1/3))` if a>=0, and for a<0, we compute `-round((-a) ** (1/3))`.
14. But we must be cautious: for example, (-8)**(1/3) is complex in Python, so we should avoid direct calculation for negatives.
15. Therefore, we'll handle negative `a` by converting to positive first.
16. Steps:
    - If a == 0: return True.
    - Let `abs_a = abs(a)`
    - Compute cube root candidate: `x = round(abs_a ** (1/3))`
    - Check if `x*x*x == abs_a`
    - Then, if original `a` was negative, the actual cube root should be negative, so we check if `(-x)*(-x)*(-x) == a` (which is equivalent to `-x*x*x == a`).
17. Actually, we can simplify: if `a` is negative, then the cube root must be negative. So we can check:
    - If `a >= 0`: check if `x*x*x == a`
    - Else: check if `(-x)*(-x)*(-x) == a` (which is `-x*x*x == a`)
18. However, note that `x` is computed from `abs(a)`, so for negative `a`, we need to check if `-x*x*x == a`.
19. But we can also just check: if `x*x*x == abs_a`, then for negative `a`, the cube is `-x*x*x`, which should equal `a`.
20. So the condition becomes:
    - If `a >= 0`: `x*x*x == a`
    - Else: `x*x*x == -a` (because `abs(a) = -a` when a<0) and then we have `- (x*x*x) = a`.
21. Therefore, we can write:
    if a >= 0:
        return x*x*x == a
    else:
        return x*x*x == -a   # because -a is positive, and we computed x from -a.
22. But wait: actually, if `a` is negative, we have `abs_a = -a`, and we computed `x = round(abs_a ** (1/3))`.
    Then the cube root of `a` should be `-x`, and we need `(-x)**3 = -x*x*x = a`.
    So we require `x*x*x = -a` (since `abs_a = -a`).
23. So the check for negative `a` is exactly `x*x*x == -a`.
24. Therefore, we can combine: we always compute `x = round(abs(a) ** (1/3))`, and then check:
    if a >= 0:
        if x*x*x == a: return True
    el