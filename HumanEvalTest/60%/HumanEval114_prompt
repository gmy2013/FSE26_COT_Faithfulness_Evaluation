
def minSubArraySum(nums):
    """
    Given an array of integers nums, find the minimum sum of any non-empty sub-array
    of nums.
    Example
    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1
    minSubArraySum([-1, -2, -3]) == -6
    """

The following is chain of thought:
We are to find the minimum sum of any non-empty contiguous subarray.
 This is similar to the classic "maximum subarray sum" problem (Kadane's algorithm) but for minimum.
 We can use a similar approach by iterating and keeping track of the current minimum sum ending at each index.
 Steps:
 1. Initialize two variables: current_min (to track the minimum sum ending at current index) and global_min (to track the overall minimum).
 2. Iterate through each number in the array.
 3. For each number, update current_min to be the minimum between the current number alone and the current number plus the previous current_min.
 4. Update global_min to be the minimum between global_min and current_min.
 5. Return global_min.

 Example: 
   For [2, 3, 4, 1, 2, 4]:
     We expect the answer to be 1 (from the subarray [1]).
   For [-1, -2, -3]:
     The answer is -6 (from the entire array).

 Let's code accordingly.
 Note: Since we are dealing with minimums, we initialize global_min to the first element and current_min to 0? Actually, we should be careful.
 Alternatively, we can initialize both to the first element and start from the second.

 However, a common approach for minimum subarray sum is to use a modified Kadane:
   current_min = min(nums[0], nums[0] + current_min) ... but actually we can start with:
   current_min = 0
   global_min = a large number? But wait, we have negative numbers.

 Actually, we can do:
   current_min = 0
   global_min = float('inf')
   But then we have to consider: if we reset current_min to 0 when it becomes positive? Not exactly.

 Alternatively, we can use:
   current_min = nums[0]
   global_min = nums[0]
   for i from 1 to n-1:
        current_min = min(nums[i], current_min + nums[i])
        global_min = min(global_min,