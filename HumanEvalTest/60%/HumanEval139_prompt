
def special_factorial(n):
    """The Brazilian factorial is defined as:
    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
    where n > 0

    For example:
    >>> special_factorial(4)
    288

    The function will receive an integer as input and should return the special
    factorial of this integer.
    """

The following is chain of thought:
We are to compute the product of factorials from n down to 1.
 Steps:
 1. We need to compute the factorial for each integer from 1 to n.
 2. Then multiply all these factorials together.

 However, note that the definition is:
   special_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!

 We can break this into two parts:
   a) Compute the factorial for a given number (we can write a helper function or do it iteratively).
   b) Iterate from 1 to n, compute the factorial for each number, and multiply them together.

 But note: we are multiplying factorials, so we can also compute the product without storing each factorial separately.

 However, for clarity, we can do:

   result = 1
   for i in range(1, n+1):
        # compute factorial of i
        fact_i = 1
        for j in range(1, i+1):
            fact_i *= j
        result *= fact_i

 But this has nested loops and might be inefficient for large n.

 Alternatively, we can use dynamic programming to avoid recalculating factorials:

   Let fact[1] = 1, fact[2] = 2, ... fact[i] = fact[i-1] * i

   Then we can precompute the factorials for 1 to n in an array, then multiply them.

 However, note that the problem does not require the most efficient solution, but correctness.

 Since n is not specified to be large, we can use the nested loop.

 But let's think: we are computing the product of factorials. We can also compute without storing each factorial by:

   result = 1
   current_factorial = 1
   for i in range(1, n+1):
 