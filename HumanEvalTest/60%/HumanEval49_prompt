

def modp(n: int, p: int):
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """

The following is chain of thought:
We are computing 2^n mod p.
 Since n can be large (like 1101), we use exponentiation by squaring to avoid large intermediate numbers.
 Steps:
 1. If n is 0, return 1 (since 2^0 = 1).
 2. Initialize result to 1.
 3. While n > 0:
      If n is odd, multiply result by 2 and take mod p.
      Then square 2 (i.e., compute 2^2 mod p) and update n to n//2.
 4. Actually, we can represent the exponentiation as:
    result = 1
    base = 2
    while n:
        if n % 2 == 1:
            result = (result * base) % p
        base = (base * base) % p
        n //= 2
 5. Return result.

 This method efficiently computes large powers modulo p without huge numbers.