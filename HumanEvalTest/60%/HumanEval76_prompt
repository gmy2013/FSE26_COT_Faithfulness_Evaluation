
def is_simple_power(x, n):
    """Your task is to write a function that returns true if a number x is a simple
    power of n and false in other cases.
    x is a simple power of n if n**int=x
    For example:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """

The following is chain of thought:
First, the function should check if x is a simple power of n, meaning there exists an integer k such that n**k = x.

Important cases to consider:
- If n is 1, then 1**k is always 1. So only x=1 should return true.
- If n is 0, then 0**k is 0 for k>=1, but undefined for k=0. However, the problem doesn't specify n>0, but we should handle edge cases.
- But looking at examples: n=1 is given in is_simple_power(3,1) => false, so n=1 only true for x=1.
- Similarly, n=0: if n=0, then 0**k is 0 for k>=1, and 1 for k=0? But k should be integer. However, the problem says "n**int=x", so k is integer.

Actually, the docstring says "n**int=x", meaning n raised to some integer equals x.

So, we need to find an integer k such that n**k == x.

But we must be cautious with n=0 and n=1.

Also, for n>1, we can iterate k from 0 upwards until n**k >= x.

But what if n is negative? The examples don't show negative, but the problem doesn't restrict n to positive.

However, the examples are all non-negative: n=4,2,2,2,1,3.

But the function should be general.

If n is negative, then n**k is defined for integer k, but it might be negative or positive.

For example, n=-2, k=3: (-2)**3 = -8.

So we should handle negative n.

But the problem says "simple power", and it might be assumed that n is positive? Not necessarily.

Looking at the examples, all n are positive integers.

But to be safe, we should handle general integers.

However, if n is negative and x is positive, it might be possible only for even k.

But the problem is to find an integer k such that n**k == x.

We can iterate over possible k.

But k can be negative too? The docstring says "n**int=x", and int could be negative.

For example, n=2, x=0.5? But x is integer? The examples show x as integer: 1,2,8,3,5.

So x is integer. Therefore, if k is negative, n**k is 1/(n**|k|), which is not integer unless n=1 or -1.

So for integer x, k must be non-negative.

Because if k<0, n**k is fraction (unless n=Â±1).

So we can assume k >=0.

Therefore, we only need to consider non-negative k.

Now, for n=0: 0**k is 0 for k>=1, and undefined for k=0. But k=0: 0**0 is undefined.

So for n=0:
- if x=0, we need k>=1, but k=0 is not allowed? Actually, we need to find an integer k such that 0**k = x.
- 0**k is 0 for k>=1, and undefined for k=0.
- So for x=0, we can have k=1,2,... so it should be true.
- For x=1, no k because 0**k is never 1.
- For other x, false.

But the problem says "n**int=x", and int is integer, which includes k=0.

But 0**0 is undefined, so we should avoid that.

Similarly, for n=1: 1**k =1 for any k, so only x=1 is true.

For n=-1: (-1)**k is 1 if k even, -1 if k odd. So only x=1 or x=-1 are possible.

So we need to handle these edge cases.

General approach:

1. If n == 0:
   - if x == 0: return True (with k>=1)
   - else: return False

2. If n == 1:
   - return x == 1

3. If n == -1:
   - return x == 1 or x == -1

4. For other n:
   - We iterate k starting from 0.
   - Compute power = n**k
   - If power == x, return True.
   - If power > abs(x) (if n>1) or if n is negative and we need to consider absolute value? Actually, for n>1, n**k grows quickly, so we can stop when |n**k| > |x|.
   - But for negative n, n**k alternates sign.

Actually, to be efficient, we can iterate k from 0 upwards until |n**k| >= |x| (if |n|>1), but we need to check both positive and negative for negative n.

Alternatively, we can use logarithms? But with integers, it's better to iterate.

Since k is integer and non-negative, we can do:

k = 0
while True:
   power = n**k
   if power == x:
        return True
   if abs(power) > abs(x):  # but careful if n is negative and k even/odd
        break
   k += 1

But for n with |n|>1, n**k grows quickly, so it's efficient.

But for n=0,1,-1 we already handled.

Also, for n=0, we handled.

Now, what if x=0 and n !=0? Then we need n**k=0, which is only possible if n=0, which we handled.

So for n !=0, x=0 is false.

Similarly, if x=1, it might be true for k=0 for any n (except n=0), because n**0=1.

Ah! Important: k=0 is allowed, and n**0=1 for any n !=0.

So for any n !=0, if x=1, it is true with k=0.

But in the example: is_simple_power(1,4) => true, which is n=4, x=1, true because 4**0=1.

Similarly, is_simple_power(2,2) => true: 2**1=2.

is_simple_power(8,2) => true: 2**3=8.

is_simple_power(3,2) => false: no k such that 2**k=3.

is_simple_power(3,1) => false: n=1, only x=1 is true, so x=3 false.

is_simple_power(5,3) => false.

So we need to include k=0.

Therefore, in the general case, we start k from 0.

Now, for n negative, we need to compute n**k for each k.

But since k is integer, it's fine.

Algorithm:

if n == 0:
    return x == 0   # because 0**k=0 for k>=1, and we don't have k=0 because undefined.
But wait: sho