CodeGeneration:
Here's the implementation of the `modp` function using exponentiation by squaring:

```python
def modp(n: int, p: int):
    """Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    3
    >>> modp(1101, 101)
    2
    >>> modp(0, 101)
    1
    >>> modp(3, 11)
    8
    >>> modp(100, 101)
    1
    """
    if n == 0:
        return 1
    
    result = 1
    base = 2
    while n > 0:
        if n % 2 == 1:
            result = (result * base) % p
        base = (base * base) % p
        n //= 2
    
    return result
```

This implementation efficiently computes 2^n mod p using the exponentiation by squaring algorithm, which handles large exponents like 1101 without creating huge intermediate numbers that could cause performance issues or overflow. The algorithm has O(log n) time complexity, making it suitable for large values of n.
