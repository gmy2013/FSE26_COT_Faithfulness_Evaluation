
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """

The following is chain of thought:
We are going to sort the list `nums` based on the sum of the digits of each number.
 However, note that negative numbers: we should consider the digits without the sign? Actually, the example includes negative numbers.
 In the example: 
   -1 has digits [1] -> sum=1
   -11 has digits [1,1] -> sum=2
   1 has digits [1] -> sum=1
   -12 has digits [1,2] -> sum=3
   11 has digits [1,1] -> sum=2

 So the sorted order by sum: 
   sums: -1 (1), 1 (1) -> then -11 (2), 11 (2) -> then -12 (3)
 But the example output is: [-1, -11, 1, -12, 11]

 Wait, note the example output: 
   First group (sum=1): -1 and 1. But why -1 comes first? Because the problem says: if same sum, order by original index.
   In the input list [1, 11, -1, -11, -12]:
        index0: 1 -> sum=1
        index1: 11 -> sum=2
        index2: -1 -> sum=1
        index3: -11 -> sum=2
        index4: -12 -> sum=3

   So for sum=1: we have index0 (1) and index2 (-1). But the example output has -1 first and then 1? 
   Actually, the problem says: "order them based on their index in original list" meaning that we should preserve the original relative order for same sum? 
   But wait: the example output for the same sum group (1) has -1 (index2) first and then 1 (index0). That doesn't seem to be by index.

   Let me read the problem again: "order them based on their index in original list". This might mean that we should use the original index as a tie-breaker? 
   However, the example output does not sort by index for the same sum. Actually, the problem might mean that we should not change the relative order of items with the same sum? That is stable sort.

   But the example: 
        Original indices for sum=1: 1 at index0, -1 at index2. 
        If we do a stable sort by sum, then the relative order of these two should be the same as in the original? So 1 (index0) should come before -1 (index2) because index0 < index2.
   However, the example output has -1 first and then 1. This contradicts.

   Let me check the example carefully: 
        Input: [1, 11, -1, -11, -12]
        Output: [-1, -11, 1, -12, 11]

   Actually, the example might be sorted by the sum of the absolute value of the digits? Or perhaps we are to take the digits ignoring the sign?

   The problem says: "sum of their digits". For negative numbers, the digits are the same as the absolute value? So for -1, the digits are [1] and sum=1. For -11, digits are [1,1] and sum=2.

   But why in the output for the same sum=1, -1 comes before 1? The problem says: "if there are several items with similar sum of their digits, order them based on their index in original list". 
   This likely means that we should use the original index as a secondary key? But then for same sum, we should sort by index ascending? Then 1 (index0) should come before -1 (index2). 

   Alternatively, the problem might mean that we should not change the relative order (i.e., stable sort) but the example does not do that.

   Wait, the example output might be demonstrating that the sort is not stable? Or perhaps I misread the example.

   Let me compute the sums again:
       1: sum_digits(1)=1
       11: sum_digits(11)=1+1=2
       -1: we take the digits of the absolute value? So abs(-1)=1 -> digits [1] -> sum=1
       -11: abs(-11)=11 -> digits [1,1] -> sum=2
       -12: abs(-12)=12 -> digits [1,2] -> sum=3

   So the sums are:
        1: 1
        11: 2
        -1: 1
        -11: 2
        -12: 3

   Now, if we sort by sum ascending, we get two groups: sum=1 [1, -1] and sum=2 [11, -11] and then sum=3 [-12].

   For the group sum=1: we have two numbers. The problem says: order based on their index in the original list. 
        In the original list, 1 is at index0 and -1 is at index2. So if we order by index ascending, we should have 1 (index0) first and then -1 (index2). 
   But the example output has -1 first and then 1. This is the opposite.

   This suggests that the problem might mean: if the sum is the same, then the one that appears earlier in the original list should come first? But that would put 1 before -1.

   Alternatively, the problem might have a mistake in the example? Or perhaps I misinterpreted "index in original list".

   Let me read the problem statement again: "order them based on their index in original list". This could mean that we use the index as a secondary key in the sort? But which direction? Ascending index would put earlier indices first.

   However, the example output for the same sum has the element from index2 (-1) before the element from index0 (1). So it is descending by index? That doesn't make sense.

   Another possibility: the problem means to preserve the original order for same sum? That is, the relative order in the input for same sum should be the same. In the input, for sum=1, we have 1 (index0) and then -1 (index2). So preserving order would put 1 first and then -1. But the example does the opposite.

   After re-examining the example: the output is [-1, -11, 1, -12, 11]. 
        For sum=1: -1 (from index2) and then 1 (from index0) -> this is not preserving the original order (which had 1 first then -1).

   This indicates that the example might be sorted by the sum of the digits including the sign? But then negative digits? That doesn't make sense.

   Alternatively, the problem might have a typo in the example.

   Given the confusion, I will assume that the intended behavior is:
        Sort primarily by the sum of the digits (ignoring the sign, i.e., using absolute value for digit extraction).
        For elements with the same digit sum, use the original index as a secondary key in ascending order (so that an element with a lower index comes first).

   This would yield for the example:
        For sum=1: [1 (index0), -1 (index2)] -> because index0 < index2.
        For sum=2: [11 (index1), -11 (index3)] -> because index1 < index3.
        For sum=3: [-12 (ind