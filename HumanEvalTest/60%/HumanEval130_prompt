
def tri(n):
    """Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in 
    the last couple centuries. However, what people don't know is Tribonacci sequence.
    Tribonacci sequence is defined by the recurrence:
    tri(1) = 3
    tri(n) = 1 + n / 2, if n is even.
    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.
    For example:
    tri(2) = 1 + (2 / 2) = 2
    tri(4) = 3
    tri(3) = tri(2) + tri(1) + tri(4)
           = 2 + 3 + 3 = 8 
    You are given a non-negative integer number n, you have to a return a list of the 
    first n + 1 numbers of the Tribonacci sequence.
    Examples:
    tri(3) = [1, 3, 2, 8]
    """

The following is chain of thought:
Let's break down the problem:

1. The function should return a list of the first n+1 numbers of the Tribonacci sequence.
2. The sequence starts at index 0? But note the examples: tri(3) returns [1, 3, 2, 8] which has 4 elements (indices 0 to 3).
3. However, the docstring defines:
   - tri(1) = 3   (this is for n=1, which might be index 1 in the sequence)
   - tri(2) = 2
   - tri(4) = 3
   - tri(3) = 8

But the example output for n=3 is [1, 3, 2, 8]. So the sequence includes an initial value at index 0 which is 1.

Wait: the docstring says "return a list of the first n + 1 numbers". So for n=3, we return 4 numbers: indices 0,1,2,3.

Now, what is the value for n=0? The docstring doesn't define it. But the example output includes 1 at index0.

Also, the recurrence for odd n uses tri(n+1), which is a forward reference. This suggests we need to compute recursively but with memoization to avoid infinite recursion.

However, note that the recurrence for odd n is:
   tri(n) = tri(n-1) + tri(n-2) + tri(n+1)   for n odd.

This is problematic because it depends on a future value. But observe the examples:

For n=3 (odd):
   tri(3) = tri(2) + tri(1) + tri(4)
   We know tri(2)=2, tri(1)=3, and tri(4)=3 (from the docstring). So tri(3)=2+3+3=8.

So how do we compute without knowing the future? Actually, we can rearrange the recurrence for odd n:

   tri(n) = tri(n-1) + tri(n-2) + tri(n+1)
   => tri(n+1) = tri(n) - tri(n-1) - tri(n-2)

But that doesn't help directly.

Alternatively, we can express tri(n+1) in terms of lower terms? Actually, for n odd, the recurrence defines tri(n) in terms of tri(n+1). This is unusual.

Wait, let's look at the recurrence for n odd: it is defined in terms of n-1, n-2, and n+1. So to compute tri(n) for odd n, we need to know tri(n+1). This suggests that we cannot compute in increasing order.

But the example computes tri(3) by knowing tri(4). So we need to know higher indices first.

However, the problem asks for the first n+1 numbers (from index0 to index n). So for a given n, we only need up to index n.

But the recurrence for odd k (k<=n) might require tri(k+1), which if k+1 <= n, we need to compute it first. This suggests we need to compute from high indices down to low? Or use a different approach.

Actually, the recurrence for even n is straightforward: tri(n) = 1 + n/2.
For odd n, we have: tri(n) = tri(n-1) + tri(n-2) + tri(n+1)

Rearrange for odd n (n>=1):
   tri(n+1) = tri(n) - tri(n-1) - tri(n-2)

But this is for odd n. So if we know tri(n), we can get tri(n+1). However, we want to compute from low to high.

Alternatively, we can express the recurrence for odd n in a different way. Notice that for n odd, the recurrence is implicit. But we can solve for tri(n) if we know tri(n+1). But we don't.

Wait, the docstring gives an example: tri(4)=3. And 4 is even, so tri(4)=1+4/2=3. So even terms are known directly.

So for even n, we have a closed form.

For odd n, we have:
   tri(n) = tri(n-1) + tri(n-2) + tri(n+1)

But tri(n+1) is even if n+1 is even? Because n is odd, so n+1 is even. So tri(n+1) = 1 + (n+1)/2.

Therefore, for odd n:
   tri(n) = tri(n-1) + tri(n-2) + [1 + (n+1)/2]

So we can write:
   tri(n) = tri(n-1) + tri(n-2) + 1 + (n+1)/2

Now it is explicit.

So to summarize:
   if n is even: tri(n) = 1 + n/2
   if n is odd: tri(n) = tri(n-1) + tri(n-2) + 1 + (n+1)/2
