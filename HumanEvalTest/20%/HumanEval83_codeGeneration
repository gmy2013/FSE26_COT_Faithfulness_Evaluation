20%CoT
CodeGeneration:
umbers that end with 1**: The last digit must be 1 (1 option). The first digit can be from 1 to 9 (9 options, since it cannot be 0), and the middle n-2 digits can be from 0 to 9 (10 options each). So, count_end = 9 * (10 ** (n-2)) * 1? Wait, but if n=1, this formula doesn't hold because there are no middle digits. Let's be careful.

Actually, for n-digit numbers ending with 1:
- The last digit is fixed to 1: 1 option.
- The first digit must be from 1 to 9 (cannot be 0): 9 options.
- The digits in between (if any) can be 0-9: 10^(n-2) options.
So, count_end = 9 * (10 ** (n-2)) * 1 = 9 * 10**(n-2) for n>=2.
But for n=1, if we plug in n=1: 9 * 10**(-1) which is not defined. So we need to handle n=1 separately.

For n=1: numbers that end with 1 are just the number 1. Also, numbers that start with 1 are the same. So for n=1, the count should be 1.

Alternatively, we can use inclusion-exclusion:
Let A be the set of numbers starting with 1.
Let B be the set of numbers ending with 1.
We want |A ∪ B| = |A| + |B| - |A ∩ B|

So:
|A| = count of numbers starting with 1 = 1 * 10**(n-1)   [first digit fixed to 1, rest any]
|B| = count of numbers ending with 1: first digit 1-9 (9 options), last digit fixed to 1, middle 10**(n-2). So |B| = 9 * 10**(n-2) for n>=2. For n=1, |B|=1.
|A ∩ B| = numbers that both start and end with 1: first digit=1, last digit=1, middle digits any: 10**(n-2) for n>=2. For n=1, it's 1.

So for n>=2:
|A| = 10**(n-1)
|B| = 9 * 10**(n-2)
|A ∩ B| = 10**(n-2)
So |A ∪ B| = 10**(n-1) + 9*10**(n-2) - 10**(n-2) = 10**(n-1) + 8*10**(n-2)

For n=1:
|A| = 1
|B| = 1
|A ∩ B| = 1
So |A ∪ B| = 1 + 1 - 1 = 1

We can write a general formula that works for n>=1:
Notice that for n=1, 10**(n-1)=10**0=1, and 10**(n-2)=10**(-1) which is not defined. So we need to handle n=1 as a special case, or we can express |B| and |A∩B| in a way that works for n=1.

Alternatively, we can compute:
|A| = 10**(n-1)
|B| = 9 * 10**(n-2)   if n>=2, and 1 if n=1.
|A∩B| = 10**(n-2) if n>=2, and 1 if n=1.

But to avoid conditionals, we can use:
For n>=1:
|A| = 10**(n-1)
|B| = 9 * 10**(n-2) + (1 if n==1 else 0)   but this is messy.

Another way: note that the formula for |B| for n>=2 is 9*10**(n-2), and for n=1 it is 1. But 1 = 9*10**(-1) + 1? Not helpful.

Actually, we can think of |B| as: total n-digit numbers that end with 1. The first digit has 9 choices (1-9), and the remaining n-1 digits have 10 choices each, but the last one is fixed to 1. Wait, that's not right: the last digit is fixed, so the number of choices for the first n-1 digits: the first digit must be 1-9 (9 choices), and the next n-2 digits can be anything (10 choices each). So indeed |B| = 9 * 10**(n-2) for n>=2.

For n=1, the number is just the digit 1, so |B|=1.

So in code, we can do:
if n == 1:
    return 1
else:
    start = 10**(n-1)
    end = 9 * 10**(n-2)
    both = 10**(n-2)
    return start + end - both

But let's verify with n=2:
n=2: numbers from 10 to 99.
Start with 1: 10,11,...,19 -> 10 numbers.
End with 1: 11,21,31,...,91 -> 9 numbers.
Both: 11 -> 1 number.
So total = 10 + 9 - 1 = 18.
And indeed: 10,11,12,13,14,15,16,17,18,19,21,31,41,51,61,71,81,91 -> 18 numbers.

Now, the expression for n>=2: start=10**(1)=10, end=9*10**0=9, both=10**0=1, so 10+9-1=18. Correct.

So code:

We'll handle n=1 separately.

But note: the problem says "n-digit positive integers", so n>=1.

Let's write the code accordingly.
```python
def starts_one_ends(n):
    """
    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    """
    if n == 1:
        return 1
    else:
        count_start = 10 ** (n - 1)
        count_end = 9 * 10 ** (n - 2)
        count_both = 10 ** (n - 2)
        return count_start + count_end - count_both
```
