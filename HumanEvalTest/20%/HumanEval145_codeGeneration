20%CoT
CodeGeneration:
10
        return s
4. Sort the list of tuples by key: (digit_sum(number), index)
   Since we want ascending order by digit sum, and then by index (which is naturally ascending in the original order).
5. Extract the numbers from the sorted list.

But note: when we have (index, number), we can sort by key=lambda x: (digit_sum(x[1]), x[0])
Then we get the sorted list of tuples, and we can take the number part.

Let's write the code accordingly.

However, we can also avoid creating a separate function for digit_sum by using a lambda inside the key? But for clarity, we can define a helper function.

But the problem says "write a function", so we can define inner function or just compute in lambda.

Let's code.

Note: for negative numbers, we take absolute value for digit sum, so -11 and 11 have same digit sum (1+1=2).

Example: [1, 11, -1, -11, -12]
Digit sums:
1: 1
11: 1+1=2
-1: abs(-1)=1 -> digit sum 1
-11: abs(-11)=11 -> 1+1=2
-12: abs(-12)=12 -> 1+2=3

So sorted by digit sum: first group with sum=1: numbers 1 and -1. But which comes first? Original indices: 
index0: 1
index2: -1
So we should have -1 first? Wait, the example output is [-1, -11, 1, -12, 11] which means:
-1 (digit sum=1) comes first, then -11 (digit sum=2), then 1 (digit sum=1), then -12 (digit sum=3), then 11 (digit sum=2).

Why is -1 before 1? Because they have same digit sum, and we order by original index: 
1 is at index0, -1 is at index2. So if we sort by digit sum and then by index (ascending), then for digit sum=1, we have index0 (1) and index2 (-1). So ascending index would put index0 first, then index2. So 1 would come before -1.

But the example output has -1 first and then 1. This contradicts.

Wait, the problem says: "order them based on their index in original list". This means that for same digit sum, the element that appeared first (lower index) should come first? Then 1 (index0) should come before -1 (index2). But the example output has -1 before 1.

There is a misunderstanding.

Let me read the example again: 
>>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]

So the output is [-1, -11, 1, -12, 11]. This means:
-1 (digit sum=1) at position0
-11 (digit sum=2) at position1
1 (digit sum=1) at position2
-12 (digit sum=3) at position3
11 (digit sum=2) at position4

So for the same digit sum (1), we have -1 and 1. In the original list, 1 is at index0 and -1 is at index2. So if we want to preserve the original order for same digit sum, then we should have 1 first (because it appears first) and then -1. But the example has -1 first and then 1.

This is confusing.

Wait, the problem says: "order them based on their index in original list". This might mean that we should not change the relative order of items with the same digit sum. So in the original list, for digit sum=1, we have 1 at index0 and -1 at index2. So in the sorted list, 1 should come before -1 because it has a lower index.

But the example output has -1 before 1. So either the example is wrong, or I misinterpreted.

Let me check the digit sums again:
1: digit sum=1
11: digit sum=2
-1: digit sum=1 (abs)
-11: digit sum=2
-12: digit sum=3

So if we sort by digit sum ascending:
digit sum=1: [1, -1]  -> but which first? If we stable sort by original order, then 1 (index0) comes before -1 (index2). So we should have [1, -1] for this group.
digit sum=2: [11, -11] -> original order: 11 at index1, -11 at index3 -> so [11, -11]
digit sum=3: [-12] at index4

So overall: [1, -1, 11, -11, -12] but this is not matching the example.

The example output is [-1, -11, 1, -12, 11]. This suggests that the sorting is not stable by index, but rather by something else.

Perhaps the problem means: when two numbers have the same digit sum, order them in the same order as they appear in the original list? So for digit sum=1, the original list has 1 first and then -1, so in the sorted list we should have 1 then -1. But the example has -1 then 1.

 unless the example is given with a mistake.

Another possibility: the problem might mean that we order by the digit sum, and for ties, we do not change the order from the original list. So the relative order of tied elements should be the same as in the input. So for input [1, 11, -1, -11, -12], the elements with digit sum=1 are 1 (index0) and -1 (index2). So in the sorted list, they should appear in the same relative order: first 1, then -1.

But the example output has -1 first and then 1.

This is not matching.

Let me read the problem statement again: "order them based on their index in original list."

This is ambiguous. It could mean that we use the index as a tie-breaker (lower index comes first), or it could mean that we preserve the original order (which is the same as stable sort).

In Python, if we use sorted with key, it is stable for ties. So if we only use digit sum as key, the original order for same digit sum will be preserved.

So for input [1, 11, -1, -11, -12]:
We have:
index0: 1 (digitsum=1)
index1: 11 (digitsum=2)
index2: -1 (digitsum=1)
index3: -11 (digitsum=2)
index4: -12 (digitsum=3)

If we sort by digitsum only, the sorted list will have:
First digitsum=1: the elements are taken in the order they appear: first index0 (1), then index2 (-1).
Then digitsum=2: index1 (11), then index3 (-11).
Then digitsum=3: index4 (-12).

So the result would be [1, -1, 11, -11, -12].

But the example expects [-1, -11, 1, -12, 11].

This is completely different.

So there is a mistake in my understanding or in the example.

Perhaps the digit sum for negative numbers should be calculated with the negative sign? But the problem says "sum of their digits", and usually we consider digits without sign.

Another idea: maybe the sorting is not stable, but we should order by the digit sum, and for ties, order by the value itself? Or by the original index in a different way.

Let's look at the example output: [-1, -11, 1, -12, 11].
The digit sums:
-1: 1
-11: 2
1: 1
-12: 3
11: 2

So the digit sums are in order: 1,2,1,3,2. This is not sorted.

 unless the sorting is not by the digit sum alone.

Perhaps the problem is to sort by the digit sum, but if there is a tie, then the number that appears first in the original list should be placed first in the sorted list? But then for digit sum=1, we have 1 (index0) and -1 (index2), so 1 should come before -1.

But in the example, -1 comes before 1.

 unless the example is wrong.

Given the time, I will assume that the example is correct and there is a different interpretation.

Another possibility: "order them based on their index in original list" might mean that when two have the same digit sum, the one with the lower index should come later? Or something else.

This is not clear.

Since the example is given, I will hard code to match the example.

For the sake of completing the code, I will write the function that sorts by digit sum, and for ties, by the original index (lower index first).

Then for the example, it will give [1, -1, 11, -11, -12], which is not the example output.

But perhaps the example has a mistake.

Given the instructions, I will implement the most reasonable approach: sort by digit sum (using absolute value), and for ties, use the original index (lower index first).

So code accordingly.

```python
def order_by_points(nums):
    if not nums:
        return []
    
    def digit_sum(n):
        n_abs = abs(n)
        s = 0
        while n_abs:
            s += n_abs % 10
            n_abs //= 10
        return s
    
    # Create list of (index, number)
    indexed_nums = list(enumerate(nums))
    # Sort by digit sum, then by index
    sorted_indexed = sorted(indexed_nums, key=lambda x: (digit_sum(x[1]), x[0]))
    return [num for index, num in sorted_indexed]
```

This will work for the empty list, and for general cases.

For the example, it will return [1, -1, 11, -11, -12], which is not equal to the example output. But based on the problem statement, this should be correct.

Perhaps the example is for a different problem.

I will output the code as above.
```python
def order_by_points(nums):
    if not nums:
        return []
    
    def digit_sum(n):
        n_abs = abs(n)
        s = 0
        while n_abs:
            s += n_abs % 10
            n_abs //= 10
        return s
    
    indexed_nums = list(enumerate(nums))
    sorted_indexed = sorted(indexed_nums, key=lambda x: (digit_sum(x[1]), x[0]))
    return [num for idx, num in sorted_indexed]
```
