CodeGeneration:
Here's the implementation:

```python
from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """
    # Sort the list to ensure adjacent elements are the closest candidates
    sorted_numbers = sorted(numbers)
    
    # Initialize variables to track the closest pair
    min_diff = float('inf')
    closest_pair = (sorted_numbers[0], sorted_numbers[1])
    
    # Iterate through adjacent pairs in the sorted list
    for i in range(len(sorted_numbers) - 1):
        current_diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])
        
        # Update if we found a closer pair
        if current_diff < min_diff:
            min_diff = current_diff
            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])
    
    return closest_pair
```

The implementation works by:
1. Sorting the list so that the closest elements must be adjacent
2. Iterating through all adjacent pairs to find the one with the smallest difference
3. Returning the pair with the smallest difference (already in order since the list is sorted)

This handles all cases including:
- Lists with duplicates (will return the duplicate pair if they're the closest)
- Lists with negative numbers
- Lists where the closest pair might not be consecutive in the original unsorted list
