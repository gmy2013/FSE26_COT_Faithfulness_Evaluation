
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''

The following is chain of thought:
We are given a list of integers. We need to check two conditions:
1. The list must be sorted in ascending order.
2. There should be no more than one duplicate of any number (i.e., no number appears more than twice? Actually, the docstring says "if list has more than 1 duplicate of the same number, return False". 
   Note: "duplicate" means an extra occurrence. So if a number appears exactly once: no duplicate. If it appears twice: one duplicate. If it appears three times: two duplicates? But the docstring says "more than 1 duplicate", meaning if there are two or more duplicates (i.e., the number appears three or more times) then return False.

However, looking at the examples:
- [1,2,2,3,3,4] -> True: here 2 appears twice (one duplicate) and 3 appears twice (one duplicate) -> allowed.
- [1,2,2,2,3,4] -> False: here 2 appears three times (two duplicates) -> not allowed.

So the rule is: for any number, if it appears more than twice (i.e., count >= 3) then return False.

But wait: what if a number appears exactly twice? That is one duplicate and is allowed. So we need to check for any element having frequency >= 3.

Alternatively, we can think: if any number appears more than twice, return False. Otherwise, check if the list is sorted.

However, note: the list must be sorted. So we can first check for duplicates (if any number has count>=3) and then check if sorted.

But also note: if the list is not sorted, we return False regardless of duplicates.

So the plan:
1. Check for duplicates: if any number appears at least 3 times, return False.
2. Check if the list is sorted in ascending order.

But wait: what if the list is not sorted but has no duplicates? Then we return False because it is not sorted.

So we can do:
- First, check for the duplicate condition: if any element has frequency >=3, return False.
- Then, check if the list is sorted. If yes, return True; else False.

Alternatively, we can combine: if there is any duplicate violation, return False. Then check sorted.

But note: the problem says "if list has more than 1 duplicate of the same number, return False". So even if the list is sorted, if there is a number with three occurrences, we return False.

So the steps:
1. Count the frequency of each number. If any number has frequency >=3, return False.
2. Check if the list is sorted. We can iterate through the list and check if each element is <= the next.
3. If both conditions are satisfied, return True.

However, what about efficie