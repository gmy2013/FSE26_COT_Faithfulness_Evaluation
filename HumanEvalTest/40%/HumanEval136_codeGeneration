CodeGeneration:
Here's the implementation of the function based on the docstring and chain of thought:

```python
def largest_smallest_integers(lst):
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
    largest_neg = None
    smallest_pos = None
    
    for num in lst:
        if num < 0:  # Negative number
            if largest_neg is None or num > largest_neg:
                largest_neg = num
        elif num > 0:  # Positive number
            if smallest_pos is None or num < smallest_pos:
                smallest_pos = num
    
    return (largest_neg, smallest_pos)
```

This implementation:
1. Initializes `largest_neg` and `smallest_pos` to `None`
2. Iterates through each number in the list
3. For negative numbers, finds the largest one (closest to zero)
4. For positive numbers, finds the smallest one (closest to zero)
5. Returns a tuple with the results

The function handles edge cases like empty lists, lists with only zeros, and lists with mixed positive/negative numbers as specified in the examples.
