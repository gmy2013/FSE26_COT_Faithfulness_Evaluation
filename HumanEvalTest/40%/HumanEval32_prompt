import math


def poly(xs: list, x: float):
    """
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """ xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """

The following is chain of thought:
We are given that the polynomial has an even number of coefficients and the largest non-zero coefficient (so the polynomial is non-constant).
 Since the polynomial has real coefficients and even degree (because the list length is even, meaning degree = len(xs)-1 is odd? Wait: 
 Actually, if the list has n elements, the polynomial is of degree n-1. So if n is even, then n-1 is odd. But the docstring says "even number of coefficients", meaning the list length is even. So degree = len(xs)-1 is odd.
 However, the docstring also says "largest non zero coefficient", meaning the leading coefficient is non-zero. So we have an odd-degree polynomial.
 An odd-degree polynomial always has at least one real root.

 We can use a simple method like the bisection method to find a root.

 Steps:
 1. Since the polynomial is odd-degree, as x -> -∞, poly(x) -> -∞ (if leading coefficient is positive) or +∞ (if negative). Similarly as x->∞, poly(x) -> ∞ if leading coeff positive, else -∞.
    So we can find two points a and b such that poly(a) and poly(b) have opposite signs.

 2. We can start with a wide interval, say [-1000, 1000], and then narrow down using bisection.

 3. Alternatively, we can use Newton's method, but that requires the derivative. However, we are not given the derivative function.

 4. Since the problem guarantees a solution, we can use bisection.

 Implementation of bisection:
   Let a = -1, b = 1 initially. But if the root is not in [-1,1], we may need to expand.
   Alternatively, we can set a and b to large values with opposite signs.

   How to choose initial a and b?
   Since the polynomial is odd-degree, we know that for large |x|, the polynomial has opposite signs at -M and M for large M.
   So we can set a = -1000.0, b = 1000.0.

   Then we itera