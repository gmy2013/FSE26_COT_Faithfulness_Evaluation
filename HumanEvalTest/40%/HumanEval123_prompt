
def get_odd_collatz(n):
    """
    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.

    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined
    as follows: start with any positive integer n. Then each term is obtained from the 
    previous term as follows: if the previous term is even, the next term is one half of 
    the previous term. If the previous term is odd, the next term is 3 times the previous
    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.

    Note: 
        1. Collatz(1) is [1].
        2. returned list sorted in increasing order.

    For example:
    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.
    """

The following is chain of thought:
We are generating the Collatz sequence for n and collecting all odd numbers.
 Since the sequence ends at 1 (which is odd), we must include it.
 Steps:
 1. Initialize an empty list to collect odd numbers.
 2. Start with the given number n.
 3. While n is not 1, do:
      - If n is odd, add it to the list and then update n to 3*n+1.
      - Else (n is even), update n to n//2.
 4. After the loop, we must add 1 (since the sequence ends at 1).
 5. Sort the list (though the order of collection might not be sorted) and return.

 However, note: the example for n=5: sequence is [5,16,8,4,2,1]. The odd numbers are 5 and 1.
 But if we collect as we go, we get [5] and then at the end we add 1. Then we sort to get [1,5].

 Implementation:
   odd_list = []
   current = n
   while current != 1:
        if current % 2 == 1:
            odd_list.append(current)
            current = 3 * current + 1
        else:
            current = current // 2
   odd_list.append(1)   # because we break at 1, so we need to add it.
   Then sort and return.

 However, note: what if n is 1? Then we should return [1]. So we must handle that.

 Alternatively, we can use a while loop that includes 1? Actually, we break at 1, so we need to add it separately.

 But we can also do:
   odd_list = []
   current = n
   while True:
        if current % 2 == 1:
            odd_list.append(current)
        if current == 1:
            break
        elif current % 2 == 0:
            current = current // 2
        else:
            current = 3 * current + 1

   Then sort.

 However, this might be inefficient because we are appending and then sorting. But n is a posit