CodeGeneration:
- For each character in the first string:
        if char is '(', balance += 1
        else: balance -= 1
        if balance < 0: break (unbalanced at this point)
    - Then for the second string:
        same update
    - If after both, balance == 0 and never went negative, it's balanced.
   - But note: the minimum balance during the entire traversal must not be negative.
7. **However**: The above simulation for one order might not be sufficient if the first string ends with a positive balance (open parentheses) and the second string starts with closing ones. But our step-by-step check with a counter exactly captures the requirement.
8. **Plan**:
   - For order1 = lst[0] + lst[1]:
        Check if the concatenation is balanced by simulating without building the string.
   - Similarly for order2 = lst[1] + lst[0].
   - If either is balanced, return 'Yes', else 'No'.

9. **Write helper function `is_valid_concatenation(s1, s2)`** that checks if the concatenation s1 followed by s2 is balanced.

Implementation of helper:
    balance = 0
    for char in s1:
        if char == '(': balance += 1
        else: balance -= 1
        if balance < 0: return False  # too many closing
    for char in s2:
        if char == '(': balance += 1
        else: balance -= 1
        if balance < 0: return False
    return balance == 0

But note: This helper is correct because it checks that the balance never goes negative and ends at zero.

10. Then in main function:
    if is_valid_concatenation(lst[0], lst[1]) or is_valid_concatenation(lst[1], lst[0]):
        return 'Yes'
    else:
        return 'No'

Let's code accordingly.
```python
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
    s1, s2 = lst
    
    def is_valid_concatenation(a, b):
        balance = 0
        for char in a:
            if char == '(':
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
        for char in b:
            if char == '(':
                balance += 1
            else:
                balance -= 1
            if balance < 0:
                return False
        return balance == 0
    
    if is_valid_concatenation(s1, s2) or is_valid_concatenation(s2, s1):
        return 'Yes'
    else:
        return 'No'
```
