
def get_row(lst, x):
    """
    You are given a 2 dimensional data, as a nested lists,
    which is similar to matrix, however, unlike matrices,
    each row may contain a different number of columns.
    Given lst, and integer x, find integers x in the list,
    and return list of tuples, [(x1, y1), (x2, y2) ...] such that
    each tuple is a coordinate - (row, columns), starting with 0.
    Sort coordinates initially by rows in ascending order.
    Also, sort coordinates of the row by columns in descending order.
    
    Examples:
    get_row([
      [1,2,3,4,5,6],
      [1,2,3,4,1,6],
      [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    get_row([], 1) == []
    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]
    """

The following is chain of thought:
We are given a nested list `lst` and an integer `x`.
 We need to find all occurrences of `x` and return their coordinates as (row, column).
 The result should be sorted first by row in ascending order.
 For the same row, the coordinates should be sorted by column in descending order.

 Steps:
 1. Initialize an empty list for the result.
 2. Iterate over each row (with index i) in the given list `lst`.
 3. For each row, iterate over each element (with index j) in that row.
 4. If the element equals `x`, then we record the coordinate (i, j).
 5. After collecting all coordinates, we need to sort them:
    - First by row (ascending) - which is the first element of the tuple.
    - Then for same row, by column (descending) - which is the second element of the tuple.
 6. Return the sorted list.

 However, note: we can also collect the coordinates and then sort, but we can also build the list in a way that we traverse rows in order and for each row we traverse columns in reverse order? But wait: we are required to sort the entire list by row ascending and then by column descending. So we can also generate the list without sorting at the end if we are careful.

 Alternatively, we can do:
   For each row i (from 0 to len(lst)-1):
        For each column j (from last to first) in row i:
            if lst[i][j] == x, then append (i, j) to the result.

 But note: if we traverse the columns in reverse order for each row, then when we append for the same row, the columns will be in descending order. Then we don't need to sort by column for the same row. However, we are iterating rows in ascending order, so the overall list will be sorted by row ascending and for each row the columns are in descending order. So we can avoid a full sort.

 However, the problem says: "Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order."

 So if we generate the list by:
   result = []
   for i in range(len(lst)):
