
def is_simple_power(x, n):
    """Your task is to write a function that returns true if a number x is a simple
    power of n and false in other cases.
    x is a simple power of n if n**int=x
    For example:
    is_simple_power(1, 4) => true
    is_simple_power(2, 2) => true
    is_simple_power(8, 2) => true
    is_simple_power(3, 2) => false
    is_simple_power(3, 1) => false
    is_simple_power(5, 3) => false
    """

The following is chain of thought:
First, I need to check if x is a simple power of n. That means there should be an integer k such that n**k = x.

But I have to consider edge cases:
- If n is 1, then 1**k is always 1. So only x=1 should be true.
- If n is 0, then 0**k is 0 for k>=1, but undefined for k=0. However, the problem says n**int, so k should be integer. But 0**0 is undefined. So probably we should handle n=0 carefully.
- Also, if x is 1, then for any n (except n=0?), n**0 = 1. So x=1 should be true for any n? But look at the example: is_simple_power(1,4) is true. So yes.

Now, what if n is negative? The problem doesn't specify, but since it's about simple power, probably we assume n is positive? The examples are all positive.

Similarly, x should be positive? Because if n is positive, n**k is always positive.

So I'll assume n and x are positive integers.

Steps:
1. If n == 1:
   - then if x == 1, return True (since 1**any =1, but we need integer exponent, so k=0 or k=1, etc., but all give 1)
   - else return False (because 1**k is always 1, so if x !=1, it's false)

2. If n <=0 or x <=0, maybe return False? But the problem doesn't specify negative, so probably assume positive.

3. For n>1 and x>=1:
   - We need to find an integer k such that n**k == x.
   - Since k is integer, we can iterate k from 0 upwards until n**k >= x.
   - For each k, compute n**k, and if it equals x, return True.
   - If n**k > x, then no need to go further, return False.

But what if x is very large? We might need to avoid infinite loop.

Alternatively, we can use logarithms: k = log(x) / log(n), and check if that is integer.

But due to floating point precision, we need to be careful.

So better to iterate.

Also, if n=0, we should handle: 0**k is 0 for k>=1, and undefined for k=0. So if n=0:
   - if x=0, then? But 0**1=0, so true? But k must be integer >=1.
   - if x=1, 0**0 is undefined, so false.
   - else false.

But the examples don't have n=0, so probably not needed.

Similarly, if n<0, bu