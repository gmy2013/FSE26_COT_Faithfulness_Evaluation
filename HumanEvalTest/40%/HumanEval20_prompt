from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """

The following is chain of thought:
Let me think through this step by step:

1. We need to find the two closest numbers in the list
2. The list has at least two elements
3. We need to return them as a tuple (smaller, larger)
4. If there are duplicates, we might have the same number twice

Approach:
- Sort the list first to make finding adjacent differences easier
- Iterate through adjacent pairs and find the pair with smallest difference
- Since the list is sorted, adjacent elements will be the closest candidates
- Handle the case where there might be multiple pairs with same minimal difference

Wait, but what if the closest pair isn't adjacent in the sorted list?
Actually, in a sorted list, the closest pair must be adjacent. Let me verify:
If we have sorted numbers [a, b, c, d] where a ≤ b ≤ c ≤ d, then for any non-adjacent pair,
the distance must be at least as lar